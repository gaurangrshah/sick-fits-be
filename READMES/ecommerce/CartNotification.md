## Cart Notification

---------------------------------

==FrontEnd== `components/CartCount.js`

---------------------------------

```react
import React from 'react'

const Dot = styled.div`
  background: ${props => props.theme.red};
  color: white;
  border-radius: 50%;
  padding: 0.5rem;
  line-height: 2rem;
  min-width: 3rem;
  margin-left: 1rem;
  font-weight: 100;
  font-feature-settings: 'tnum';
  font-variant-numeric: tabular-nums;
`;

const CartCount = ({ count }) => (
  <Dot>
    {count}
  </Dot>
)
}

export default CartCount
```





Now we can import this into `component/Nav.js`

---------------------------------

```react
import CartCount from './CartCount'
```



then we can render the component with our `My Cart` button:

```react
<button onClick={toggleCart}>
  My Cart
  <CartCount count={100}></CartCount>
</button>
```



now in order to output the actualy number of items in the cart:

```react
<CartCount count={10}>
  {/* count the # of actual items in the cart */}
  {me.cart.reduce((tally, cartItem) => tally + cartItem.quantity, 0)}
</CartCount>
```





When our notification updates, react will unmount the component and re-mount it with the new value, in this scenarios, we can use `TransitionGroup` to define a group of elements that will be transitioning. `components/CartCount.js`

```react
import { TransitionGroup, CSSTransition } from 'react-transition-group';
```

```react
<TransitionGroup>
  <CSSTransition>
    <Dot>
      {count}
    </Dot>
  </CSSTransition>
</TransitionGroup>
```

Now the csstransition component will be able to take in a number of props to define what happens with any elements that are wrapped inside as they transition

```react
<CSSTransition
  unmountOnExit
  className="count"
  classNames="count"
  key={count}
  timeout={{ enter: 4000, exit: 4000 }}
  >
```



Next we'll need to create the styles for the animation we'd like to see occur:

```react
const AnimationStyles = styled.span`
  position: relative;
  .count {
    display: block;
    position: relative;
    transition: all 4s;
    backface-visibility: hidden;
  }
`;
```



Then we can wrap our transition group within our animation styles:

```react
const CartCount = ({ count }) => (
  <AnimationStyles>
    <TransitionGroup>
      <CSSTransition
        unmountOnExit
        className="count"
        classNames="count"
        key={count}
        timeout={{ enter: 4000, exit: 4000 }}
      >
        <Dot>
          {count}
        </Dot>
      </CSSTransition>
    </TransitionGroup>
  </AnimationStyles>
);
```



Next we can use some of the the helper classes generated by the "classNames" prop we provided to CSS Transition Group:  - we passed in a value of 'count' for the prop, so it uses that value to generate these helper classes:

```react
/* targeting classes generated by Transition Group*/
.count-enter {
  transform: rotateX(.5turn);
}
count-enter-active {
  transform: rotateX(0);
}
.count-exit {
  top: 0;
  position: absolute;
  transform: rotateX(0);
}
count-exit-active {
  transform: rotateX(0.5turn);
}
```



There is some cleanup we need to do, currenly we get an error when an item gets removed from our inventory (so its no longer avaialble for purchase, and shouldn't be in anyone's cart.) because the item is required to be returned back to us, so in our `datamodel.primsa`: ==BackEnd==

```react
  item: Item #relationship to item
```

> we've remove the require(`!`) from item, allowing the cartitem to not have an item if it's been removed. 

becase we've  updated the datmodel we need to redeploy to prisma:

```shell
yarn deploy
```

> this will have also updated our generated schema from prisma, to reflect this change.



==FrontEnd== `components/CartItem.js`

---------------------------------

```react
  // Check if item exists:
  if (!cartItem.item) return (
    <CartItemStyles>
      <p>This Item has been removed</p>
      {/* allows user to remove notification and remenants of item */}
      <RemoveFromCart id={cartItem.id} />
    </CartItemStyles>
  )
```

